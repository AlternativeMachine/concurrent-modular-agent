{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Concurrent Modular Agent Documentation","text":"<p>Version: 0.0.0</p> <p>For full documentation visit mkdocs.org. </p> <p>Concurrent Modular Agent (CoMA) is a framework for building modular agents that can work concurrently. It allows developers to create agents that can perform multiple things simultaneously as concurrent modules. This makes the way of building agents a bit different from the traditional way of building agents as workflows. </p> <p>To get started with CoMA, you can follow the steps in Getting Started.</p>"},{"location":"getting-started/creating-a-new-project/","title":"2. Creating a New Project","text":"<p>CoMA is designed as project-oriented, meaning that you create modules and an assembly of modules (=agent) within a project. You can make either of the following two styles of projects: 1. CoMA Interface Project: you write definitions of modules and run them as a single agent with <code>coma run</code> command. This is the simplest way to use CoMA. 2. Python Interface Project: you write definitions of modules and agents and run them as more than one agent with <code>python</code> command. This is the most flexible way to use CoMA. </p> <p>Regardless of the styles of project, you can create a new project simply making a directory. For Python Interface Project, this directory stores <code>python</code> scripts that define modules and agents. For CoMA Interface Project, you need to create one more depth of directory which corresponds to an agent and stores definitions of modules comprising the agent.</p> <p>For instance, your CoMA Interface Project style <code>sample_project</code> directory can look like this:</p> <pre><code>sample_project/    # Project directory\n\u251c\u2500\u2500 agent1/        # Agent directory\n\u2502   \u251c\u2500\u2500 module1.py # Defines module1\n\u2502   \u251c\u2500\u2500 module2.py # Defines module2\n\u2502   \u2514\u2500\u2500 module3.py # Defines module3\n\u2514\u2500\u2500 agent2/\n    \u251c\u2500\u2500 module1.py\n    \u251c\u2500\u2500 module2.py\n    \u2514\u2500\u2500 module3.py\n</code></pre> <p>For Python Interface Project, it can look like this:</p> <pre><code>sample_project/ # Project directory\n\u251c\u2500\u2500 module1.py  # Defines module1\n\u251c\u2500\u2500 module2.py  # Defines module2\n\u2514\u2500\u2500 module3.py  # Defines module3\n\u251c\u2500\u2500 agent1.py   # Defines an agent that uses module1, module2, and module3\n\u2514\u2500\u2500 agent2.py   # Defines another agent that uses module1, module2, and module3\n</code></pre> <p>To start with, we will introduce the CoMA Interface Project style, which is simpler and more straightforward for beginners. You can skip to the Python Interface Project style if you are already familiar with Python and want to use CoMA in a more flexible way.</p>          \ud83d\ude80 Creating Modules (CoMA Interface)"},{"location":"getting-started/creating-modules/","title":"3. Creating Modules (CoMA Interface)","text":""},{"location":"getting-started/creating-modules/#make-a-modeule","title":"Make a modeule","text":"<p>In this section, we will create three simple modules that well explain the basic concepts of CoMA modules. These modules will be used to build a simple chat application that can respond to user input. We will create the following modules:</p> <ol> <li> <p><code>user_input</code>: A module that receives user input and sends it to the <code>chat</code> module.</p> </li> <li> <p><code>chat</code>: A module that receives messages from the <code>user_input</code> module and responds to the user.</p> </li> <li> <p><code>memory_organizer</code>: A module that organizes the memory of the agent.</p> </li> </ol> <p></p>"},{"location":"getting-started/creating-modules/#make-a-new-project-directory-with-agent-directory","title":"Make a new project directory with agent directory","text":"<p>To start your first project, create a directory named <code>my_project</code> and <code>my_project/agent1</code> or do </p> <pre><code>mkdir -p my_project/agent1\n</code></pre>"},{"location":"getting-started/creating-modules/#make-a-new-module-file","title":"Make a new module file","text":"<p>Next, create a file named <code>user_input.py</code> in the <code>my_project/agent1</code> directory. This file will define your first module, which is a simple chat module that can respond to user input.</p> <pre><code>touch my_project/agent1/user_input.py\n</code></pre>"},{"location":"getting-started/creating-modules/#make-a-new-module-definition","title":"Make a new module definition","text":"<p>Now, open <code>user_input.py</code> in your favorite text editor and add the following code:</p> <pre><code># my_project/agent1/user_input.py\nimport time\nimport concurrent_modular_agent as coma\n\n@coma.module_main('user_input')\ndef mod_user_input(agent:coma.AgentInterface):\n    while True:                              # continuously run this module\n        m = input(\"User: \")\n        if len(m) == 0 or m.isspace() or m is None:  # if the user input is empty, skip to the next iteration\n            continue\n        agent.state.add(f\"user_message:{m}\")\n        agent.message.send(\"chat\", \"reply to user\")  # send message to the \"chat\" module\n        time.sleep(3)                        # wait for 3 seconds before next input\n</code></pre> <p>Overall, this code defines a module named <code>user_input</code> that continuously receives user inputs. When the user enters a message (<code>m</code> in the code above), it adds the message to the agent's state and sends a message to the \"<code>chat</code>\" module to reply. </p> <p>Let's disect this code to get a sense of how CoMA modules work.</p>"},{"location":"getting-started/creating-modules/#disecting-the-module-code","title":"Disecting the module code","text":"<p>The first line imports the <code>concurrent_modular_agent</code> package, which provides the necessary functions and classes to define and run CoMA modules.</p> <p>The <code>@coma.module_main(module_name)</code> decorator instantiate an <code>AgentInterface</code> object with the specified name of the module. This object provides basic functionalities for modules, state IO and messaging IO. Using this decorator turns a function which takes an <code>AgentInterface</code> object as an argument into a module function. Notice that the <code>module_name</code> is specified as <code>'user_input'</code>, which can be different from the file name or the function name. </p> <pre><code>\n### Module function\nThe `mod_user_input` function is the main function of the module. Let's break down its components:\n```python\nwhile True:\n    ...\n    time.sleep(3)\n</code></pre> <p>This loop ensures that the module runs continuously, allowing it to receive user inputs repeatedly. The <code>time.sleep(3)</code> line introduces a 3-second delay between each input, preventing the module from overwhelming the user with prompts.</p> <pre><code>m = input(\"User: \")\nif len(m) == 0 or m.isspace() or m is None:\n    continue\n</code></pre> <p>This line receives input from the user. The input is stored in the variable <code>m</code>.  If the user input is empty (i.e., the user just pressed Enter without typing anything), only whitespace, or <code>None</code>, the module skips to the next iteration of the loop, effectively ignoring empty inputs.</p> <pre><code>agent.state.add(f'user_message:{m}')\n</code></pre> <p>This line adds the user message to the agent's state.  The state is a shared memory space where modules can store and retrieve information.  The <code>AgentInterface.state</code> object provides access to this state.  The <code>AgentInterface.state.add</code> method is used to store new information in the state. At this time, the received user input <code>user_message:{m}</code>, where <code>{m}</code> is the actual user input, is added to the state. </p> <pre><code>agent.message.send(\"chat\", \"reply\")\n</code></pre> <p>This line sends a message \"<code>reply</code>\" to the \"<code>chat</code>\" module.  The <code>message</code> object allows modules to communicate with each other by sending and receiving messages.  At this time, the <code>send</code> method is used to send a message to the \"<code>chat</code>\" module, which is expected to handle the reply.</p>"},{"location":"getting-started/creating-modules/#make-a-chat-module","title":"Make a chat module","text":"<p>Next, create a file named <code>chat.py</code> in the <code>my_project/agent1</code> directory. This file will define your second module, which is a simple chat module that can respond to user input.</p> <pre><code>touch my_project/agent1/chat.py\n</code></pre> <p>Now, open <code>chat.py</code> in your favorite text editor and add the following code:</p> <pre><code># my_project/agent1/chat.py\n@coma.module_main('chat')\ndef mod_response_to_user(agent:coma.AgentInterface):\n    openai_client = OpenAI()\n    while True:\n        m = agent.message.receive()\n        if m is None:\n            continue  # If no message is received, skip to the next iteration\n        messages = [\n            {\"role\": \"developer\", \"content\": \"You are a module of an autonomous agent. Your job is to respond to the user's input. You are expected to talk with the user. You are not an AI assistant, so feel free to talk freely. You do not need to help humans. You received the following messages from the user, other modules. Talk to the user in a natural way.\"},\n        ]\n        for s in agent.state.get(max_count=10).texts[::-1]:\n            if s.startswith(\"user_message:\"):\n                messages.append({\"role\": \"user\", \"content\": s[len(\"user_message:\"):]})\n            elif s.startswith(\"assistant_message:\"):\n                messages.append({\"role\": \"assistant\", \"content\": s[len(\"assistant_message:\"):]})\n        messages.append({\"role\": \"assistant\", \"content\": f\"{m}})\n\n        completion = openai_client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n        )\n        output_message = completion.choices[0].message.content\n        print(f'ChatBot: {output_message}')\n        agent.state.add(f\"assistant_message:{output_message}\")\n\n        agent.message.send(\"user_input\", 'chat response finished')\n</code></pre>"},{"location":"getting-started/creating-modules/#disecting-the-chat-module-code","title":"Disecting the chat module code","text":"<p>The basics are similar to the <code>user_input</code> module.  The module is defined with the <code>@coma.module_main('chat')</code> decorator, which allows it to be recognized as a module named \"<code>chat</code>\".  The <code>mod_response_to_user</code> function is the main function of the module.  It continuously listens for messages from the <code>user_input</code> module and sends responses back to the module like the last module.</p> <pre><code>@coma.module_main('chat')\ndef mod_response_to_user(agent:coma.AgentInterface):\n    ...\n    while True:\n        m = agent.message.receive()               # receive message from user_input module\n        ...\n        agent.message.send(\"user_input\", 'chat response finished') # send message to user_input module to tell it finished processing\n</code></pre> <p>There are four new things in this module code. The first is when the module activates. </p> <pre><code>while True:\n    m = agent.message.receive()\n    if m is None:\n        continue  # If no message is received, skip to the next iteration\n</code></pre> <p>The module runs continuously, waiting for messages from the <code>user_input</code> module. If the module receives a message, it activates and processes the message to respond to the user.</p> <p>The second is LLM interface. At this moment, we use OpenAI's API to interact with the LLM.</p> <pre><code>openai_client = OpenAI()\n...\n        completion = openai_client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n        )\n</code></pre> <p>The third is state retrieval. </p> <pre><code>for s in agent.state.get(max_count=10).texts[::-1]:\n    if s.startswith(\"user_message:\"):\n        messages.append({\"role\": \"user\", \"content\": s[len(\"user_message:\"):]})\n    elif s.startswith(\"assistant_message:\"):\n        messages.append({\"role\": \"assistant\", \"content\": s[len(\"assistant_message:\"):]})\n</code></pre> <p>We retrieve the latest state using <code>AgentInterface.state.get()</code>, which returns the most recent state of the agent. The <code>texts</code> property of the state object contains all text entries in the state, and we reverse it to process the most recent messages first.</p> <p>The obtained state is checked for messages that start with <code>user_message:</code> or <code>assistant_message:</code>.  If the message starts with <code>user_message:</code>, it is treated as a user message, and if it starts with <code>assistant_message:</code>, it is treated as an assistant message.  The messages are then appended to the <code>messages</code> list, which will be sent to the LLM.</p> <p>The fourth is output to the user.</p> <pre><code>output_message = completion.choices[0].message.content\nprint(f'ChatBot: {output_message}')\nagent.state.add(f'assistant_message:{output_message}')\n</code></pre> <p>The output from the LLM is stored in the <code>output_message</code> variable, which is then printed to the console.  The output message is also added to the agent's state with the prefix <code>assistant_message:</code>.</p> <p>In the end, the module sends a message to the <code>user_input</code> module to signal that it has finished processing the input and is ready for the next message.</p> <pre><code>agent.message.send(\"user_input\", 'finish')\n</code></pre>"},{"location":"getting-started/creating-modules/#make-a-memory-organizer-module","title":"Make a memory organizer module","text":"<p>Next, create a file named <code>memory_organizer.py</code> in the <code>my_project/agent1</code> directory. This file will define your third module, which is a simple memory organizer module that organizes the memory of the agent.</p> <pre><code>touch my_project/agent1/memory_organizer.py\n</code></pre> <p>Now, open <code>memory_organizer.py</code> in your favorite text editor and add the following code:</p> <pre><code># my_project/agent1/memory_organizer.py\nimport time\nimport random\n\nimport concurrent_modular_agent as coma\nfrom concurrent_modular_agent import OpenAI\n\n@coma.module_main('memory_organizer')\ndef mod_organize_memory(agent: coma.AgentInterface):\n    openai_client = OpenAI()\n    while True:\n        m = agent.message.receive()\n        messages = [\n            {\"role\": \"developer\", \"content\": \"You are a module of an autonomous agent. Your job is to organize the memory of the agent. You are expected to organize the memory of the agent in a way that is helpfull to recall the past and what the agent had thought. You will be given a list of memory of received the following messages from the user, other modules.\"},\n        ]\n        organizing_range = random.randint(5, 10)  # Randomly decide how many messages to organize\n        for s in agent.state.get(max_count=10).texts[::-organizing_range]:\n            if s.startswith(\"user_message:\"):\n                messages.append({\"role\": \"user\", \"content\": s[len(\"user_message:\"):]})\n            elif s.startswith(\"assistant_message:\"):\n                messages.append({\"role\": \"assistant\", \"content\": s[len(\"assistant_message:\"):]})\n        messages.append({\"role\": \"assistant\", \"content\": f\"{m}})\n\n        completion = openai_client.chat.completions.create(\n            model=\"gpt-4.1-nano-2025-04-14\",\n            messages=messages,\n        )\n        output_message = completion.choices[0].message.content\n        agent.state.add(f'assistant_message:{output_message}')\n\n        time.sleep(100)  # Wait for 3 seconds before next input\n</code></pre>"},{"location":"getting-started/creating-modules/#disecting-the-memory-organizer-module-code","title":"Disecting the memory organizer module code","text":"<p>The <code>memory_organizer</code> module is similar to the <code>chat</code> module, but it has a different purpose. It organizes the memory of the agent stored in the state.</p> <p>The main part of the module is collect a random numbers of states from the shared memory and send them to the LLM to organize the memory.</p> <p>This part collects 5~10 states from the agent's memory:</p> <pre><code>organizing_range = random.randint(5, 10)  # Randomly decide how many messages to organize\nfor s in agent.state.get(max_count=10).texts[::-organizing_range]:\n    if s.startswith(\"user_message:\"):\n        messages.append({\"role\": \"user\", \"content\": s[len(\"user_message:\"):]})\n    elif s.startswith(\"assistant_message:\"):\n        messages.append({\"role\": \"assistant\", \"content\": s[len(\"assistant_message:\"):]})\nmessages.append({\"role\": \"assistant\", \"content\": f\"{m}})\n</code></pre> <p>The output of the LLM is stored to memory as an <code>assistant_message</code>:</p> <pre><code>output_message = completion.choices[0].message.content\nagent.state.add(f'assistant_message:{output_message}')\n</code></pre> <p>Notice that the <code>memory_organizer</code> module does not send any message to other modules.</p>"},{"location":"getting-started/creating-modules/#concurrency-of-memory-organizer-module","title":"Concurrency of memory organizer module","text":"<p>The <code>memory_organizer</code> module is designed to run concurrently with the <code>user_input</code> and <code>chat</code> modules. This means that it can run in parallel with the other modules, allowing it to organize the memory of the agent while the user is interacting with the agent. Although both <code>user_input</code> and <code>chat</code> modules are designed to run continuously, <code>user_input</code> module will send messages only when the user inputs a message, and <code>chat</code> module will send messages only when it receives a message from the <code>user_input</code> module. The <code>memory_organizer</code> module will run continuously without activating. </p>          \ud83d\ude80 Running the Agent"},{"location":"getting-started/getting-started/","title":"Getting Started","text":"<p>We will walk through the steps to get started with CoMA, including installation, creating a new project, creating modules, connecting modules, and running the agent. </p> <p>Here is the table of contents for this guide:</p> <ol> <li> <p>Installation</p> </li> <li> <p>Creating a New Project</p> </li> <li> <p>Creating Modules</p> </li> <li> <p>Running the Agent</p> </li> </ol> <p>First, we will cover the installation process.</p>          \ud83d\ude80 Start Installation"},{"location":"getting-started/installation/","title":"1. Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing CoMA, ensure you have the following prerequisites:</p> <ul> <li> <p>Python 3.12 or later</p> <p>CoMA uses multiprocessing and asyncio, which are fully supported in Python 3.12 and later versions.</p> </li> <li> <p>Docker </p> <p>CoMA uses Docker to run modules (specifically, <code>MQTT</code> for messaging and <code>ChromaDB</code> for vector storage). Ensure you have Docker installed and running on your machine. Please refer to the Docker installation guide for instructions.</p> </li> </ul>"},{"location":"getting-started/installation/#setup","title":"Setup","text":"<p>It is recommended to use a virtual environment. </p> <pre><code>$ python -m venv .venv\n$ source .venv/bin/activate\n</code></pre> <p>Install the required packages.</p> <pre><code>$ pip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#test","title":"Test","text":""},{"location":"getting-started/installation/#1-start-backend-services","title":"1. Start backend services.","text":"<pre><code>$ coma backend start\n</code></pre> <p>Note: You need to run Docker before starting the backend services.</p> <p>Tips: for MacOS users, you need to run the Docker Desktop application. Not CLI commands.</p> <p>You can use the <code>start</code>, <code>stop</code>, and <code>restart</code> commands to manage the backend services. For example, to stop the backend services, run:</p> <pre><code>$ coma backend stop\n</code></pre>"},{"location":"getting-started/installation/#2-set-the-openai-api-key","title":"2. Set the OpenAI API Key","text":"<pre><code>$ export OPENAI_API_KEY=\"your api key\"\n</code></pre>"},{"location":"getting-started/installation/#3-run-test","title":"3. Run test.","text":"<pre><code>$ pytest\n</code></pre> <p>If you pass each test, you should see output similar to:</p> <pre><code>....\n</code></pre> <p>Otherwise, you will see output indicating which tests failed or encountered errors.</p> <pre><code>..!!!\n</code></pre> <p>Now you are ready to start building your agential systems with CoMA!</p>          \ud83d\ude80 Creating Projects"},{"location":"getting-started/running-the-agent/","title":"4. Running the Agent","text":"<p>Let's run union of modules you have created and connected as an agent. </p>"}]}